<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="k9WS1EOfLnS9AypLcsMakrYfXwMf0dUn-t3o0ISNMy4"><meta name="baidu-site-verification" content="GTIjN6Pg5u"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.d77.xyz","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="DISTINCT 关键字DISTINCT 指示数据库只返回不同的值。如果是用 DISTINCT 关键字，它必须直接放在列名的前边。"><meta property="og:type" content="article"><meta property="og:title" content="SQL必知必会笔记"><meta property="og:url" content="https://blog.d77.xyz/archives/1da172c2.html"><meta property="og:site_name" content="LLLibra146&#39;s blog"><meta property="og:description" content="DISTINCT 关键字DISTINCT 指示数据库只返回不同的值。如果是用 DISTINCT 关键字，它必须直接放在列名的前边。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blogimg.d77.xyz/qrcode_for_gh_10d7d04417bb_430.jpg"><meta property="article:published_time" content="2019-12-04T05:22:26.000Z"><meta property="article:modified_time" content="2024-12-05T14:01:21.075Z"><meta property="article:author" content="LLLibra146"><meta property="article:tag" content="SQL"><meta property="article:tag" content="必知必会"><meta property="article:tag" content="笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blogimg.d77.xyz/qrcode_for_gh_10d7d04417bb_430.jpg"><link rel="canonical" href="https://blog.d77.xyz/archives/1da172c2.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.d77.xyz/archives/1da172c2.html","path":"/archives/1da172c2.html","title":"SQL必知必会笔记"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>SQL必知必会笔记 | LLLibra146's blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-GR9YXDQ843"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-GR9YXDQ843","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?c76c7b91ebcbf02b7fc1f26bf23121ff"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">LLLibra146's blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Personal note</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">192</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">29</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">84</span></a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#DISTINCT-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.</span> <span class="nav-text">DISTINCT 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">2.</span> <span class="nav-text">限制查询返回的结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.</span> <span class="nav-text">注释语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ORDER-BY-%E8%AF%AD%E5%8F%A5%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">ORDER BY 语句排序检索数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%88%97%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">按多个列排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8E%92%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">按位置排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E5%90%91"><span class="nav-number">7.</span> <span class="nav-text">指定排序方向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WHERE-%E8%AF%AD%E5%8F%A5%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">8.</span> <span class="nav-text">WHERE 语句过滤数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WHERE-%E5%AD%90%E5%8F%A5%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%82"><span class="nav-number">9.</span> <span class="nav-text">WHERE 子句操作符。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88-WHERE-%E5%AD%90%E5%8F%A5"><span class="nav-number">10.</span> <span class="nav-text">组合 WHERE 子句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">11.</span> <span class="nav-text">求值顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IN-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">12.</span> <span class="nav-text">IN 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-OR-%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">为什么要使用 OR 操作符？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NOT-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">14.</span> <span class="nav-text">NOT 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LIKE-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">15.</span> <span class="nav-text">LIKE 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BE%E5%88%86%E5%8F%B7%EF%BC%88-%EF%BC%89%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">16.</span> <span class="nav-text">百分号（%）通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%88-%EF%BC%89%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">17.</span> <span class="nav-text">下划线（_）通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%EF%BC%88-%EF%BC%89%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">18.</span> <span class="nav-text">方括号（[]）通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="nav-number">19.</span> <span class="nav-text">使用通配符的技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">20.</span> <span class="nav-text">字段的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="nav-number">21.</span> <span class="nav-text">拼接字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D"><span class="nav-number">22.</span> <span class="nav-text">使用别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-number">23.</span> <span class="nav-text">执行算数运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">24.</span> <span class="nav-text">使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">24.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UPPER-%E5%87%BD%E6%95%B0"><span class="nav-number">24.2.</span> <span class="nav-text">UPPER() 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">24.3.</span> <span class="nav-text">一些常用的文本处理函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">24.4.</span> <span class="nav-text">日期和时间处理函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">24.5.</span> <span class="nav-text">数值处理函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">25.</span> <span class="nav-text">汇总数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-number">25.1.</span> <span class="nav-text">聚集函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E5%80%BC"><span class="nav-number">25.2.</span> <span class="nav-text">聚集不同值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="nav-number">26.</span> <span class="nav-text">分组数据</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="LLLibra146" src="https://blogimg.d77.xyz/logo.png"><p class="site-author-name" itemprop="name">LLLibra146</p><div class="site-description" itemprop="description">小时侯，幸福是很简单的事；长大了，简单是很幸福的事！</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">84</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">29</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">192</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/libra146" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;libra146" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1462326016@qq.com" title="E-Mail → mailto:1462326016@qq.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.d77.xyz/archives/1da172c2.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://blogimg.d77.xyz/logo.png"><meta itemprop="name" content="LLLibra146"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="LLLibra146's blog"><meta itemprop="description" content="小时侯，幸福是很简单的事；长大了，简单是很幸福的事！"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="SQL必知必会笔记 | LLLibra146's blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">SQL必知必会笔记</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-04 13:22:26 13:22:26" itemprop="dateCreated datePublished" datetime="2019-12-04T13:22:26+08:00">2019-12-04 13:22:26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-12-05 22:01:21 22:01:21" itemprop="dateModified" datetime="2024-12-05T22:01:21+08:00">2024-12-05 22:01:21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="DISTINCT-关键字"><a href="#DISTINCT-关键字" class="headerlink" title="DISTINCT 关键字"></a>DISTINCT 关键字</h4><p>DISTINCT 指示数据库只返回不同的值。如果是用 DISTINCT 关键字，它必须直接放在列名的前边。</p><span id="more"></span><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure><p>DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。</p><h4 id="限制查询返回的结果"><a href="#限制查询返回的结果" class="headerlink" title="限制查询返回的结果"></a>限制查询返回的结果</h4><ul><li>在 SQL Serve 和 Access 中使用 SELECT 时，可以使用 TOP 关键字来限制最多返回多少行。</li></ul><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure><ul><li><p>在 Orcale，需要机遇 ROWNUM（行计数器）来计算行。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 MySQL、MariaDB、PostgreSQL 或者 SQLite 中，需要使用 LIMIT 字句。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注释语句"><a href="#注释语句" class="headerlink" title="注释语句"></a>注释语句</h4><p>有单行注释和多行注释之分，直接上例子。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="comment">-- 这是一条注释</span></span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"># 这是一条注释</span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SELECT prod_name, vend_id</span></span><br><span class="line"><span class="comment">FROM Products; */</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure><h4 id="ORDER-BY-语句排序检索数据"><a href="#ORDER-BY-语句排序检索数据" class="headerlink" title="ORDER BY 语句排序检索数据"></a>ORDER BY 语句排序检索数据</h4><p>为了明确地排序用 SELECT 语句检索出的数据，可以使用 OEDER BY 子句。ORDER BY 子句取一个或多个列的名字，据此对输出进行排序。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p><strong>在指定一条 ORDER BY 子句时，应该保证它是 SELECT 语句中的最后一条子句。</strong></p><p>通常，ORDER BY 子句中使用的列件事为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</p><h4 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h4><p>要按多个列排序，简单指定列名，列名之间用逗号分开即可。</p><h4 id="按位置排序"><a href="#按位置排序" class="headerlink" title="按位置排序"></a>按位置排序</h4><p>除了按列名指出排列顺序外，ORDER BY 子句还支持按相对列位置进行排序。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><h4 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h4><p>数据排序不限于升序排序（从A到Z），这只是默认的排序顺序。还可以使用 ORDER BY 子句进行降序（从Z到A）排序。为了进行降序排序，必须要指定 DESC 关键字。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>用多个列排序</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name;</span><br></pre></td></tr></table></figure><p>简单来说，DESC 关键字只应用到直接位于其前面的列名。对于想要在多个列上进行降序排序，必须对每一个列指定 DESC 关键字。</p><h4 id="WHERE-语句过滤数据"><a href="#WHERE-语句过滤数据" class="headerlink" title="WHERE 语句过滤数据"></a>WHERE 语句过滤数据</h4><p>在 SELECT 语句中，数据根据 WHERE 子句中指定的搜索条件进行过滤，WHERE 子句在表明（FROM子句）之后给出。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">3.49</span>;</span><br></pre></td></tr></table></figure><p>关于 WHERE 子句的位置问题，在同时使用 ORDER BY 和 WHERE 子句时，应该让 ORDER BY 位于 WHERE 之后。</p><h4 id="WHERE-子句操作符。"><a href="#WHERE-子句操作符。" class="headerlink" title="WHERE 子句操作符。"></a>WHERE 子句操作符。</h4><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">BETWEEN</td><td align="center">在指定的两个值之间</td></tr><tr><td align="center">IS NULL</td><td align="center">为NULL值</td></tr></tbody></table><h4 id="组合-WHERE-子句"><a href="#组合-WHERE-子句" class="headerlink" title="组合 WHERE 子句"></a>组合 WHERE 子句</h4><p>操作符：用来联结或改变 WHERE 子句中的子句的关键字，也成为逻辑操作符。分别是 AND 操作符和 OR 操作符。</p><h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>SQL 在处理 OR 操作符前，优先处理 AND 操作符，AND 操作符的优先级更高。圆括号比 AND 操作符拥有更高的求值顺序。</p><h4 id="IN-操作符"><a href="#IN-操作符" class="headerlink" title="IN 操作符"></a>IN 操作符</h4><p>IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配，IN 取一组由逗号分隔、扩在圆括号中的合法值。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> ( <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span> )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><h4 id="为什么要使用-OR-操作符？"><a href="#为什么要使用-OR-操作符？" class="headerlink" title="为什么要使用 OR 操作符？"></a>为什么要使用 OR 操作符？</h4><ul><li>在有很多合法选项时，IN 操作符的语法更清楚，更直观。</li><li>在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。</li><li>IN 操作符一般比一组 OR 操作符执行的更快。</li><li>IN 最大的优点是可以包含其他 SELECT 语句，能够动态的建立 WHERE 子句。</li></ul><h4 id="NOT-操作符"><a href="#NOT-操作符" class="headerlink" title="NOT 操作符"></a>NOT 操作符</h4><p>WHERE 子句中的 NOT 操作符有且只有一个功能，那及时否定其后所跟的任何条件。以为 NOT 从不单独使用（它总是与其他操作符一起使用，所以它的语法与其他操作符有所不同）。NOT 关键字可以用在要过滤的列前，而不仅是在其后。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>为什么使用 NOT？在比较复杂的子句中，与 IN 操作符联合使用时，NOT 可以非常简单的找出与条件列表不匹配的行。</p><p><strong>大多数情况下 NOT 操作符可以否定任何条件。</strong></p><h4 id="LIKE-操作符"><a href="#LIKE-操作符" class="headerlink" title="LIKE 操作符"></a>LIKE 操作符</h4><p>首先来看两个概念。</p><p>通配符：用来匹配值的一部分的特殊字符。</p><p>搜索模式：由自勉之、通配符或两者组合构成的搜索条件。</p><p>为在搜索子句中使用通配符，必须使用 LIKE 操作符，指示数据库，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p><p>谓词：操作符合适不是操作符？答案是，它作为谓词时。从技术上说，LIKE 时谓词而不是操作符，虽然最终的结果都是相同的。</p><h4 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h4><p>最常使用的通配符时百分号（%）。在搜索串中，% 表示任何字符串出现任意次数。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;Fish%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>Access 通配符，需要使用 * 而不是 %。</strong></p><p>通配符看起来可以匹配任何东西，但是有个例外，就是 NULL，子句 WHERE xx LIKE ‘%’ 不会匹配值为 NULL 的行。</p><h4 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h4><p>下划线通配符的用途与 % 一样，但是它值匹配单个的字符，而不是多个字符。</p><p><strong>如果是 Access，需要使用 ？而不是 _</strong></p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="方括号（-）通配符"><a href="#方括号（-）通配符" class="headerlink" title="方括号（[]）通配符"></a>方括号（[]）通配符</h4><p>方括号通配符用来指定一个字符集，它必须匹配指定位置（通配符位置）的一个字符。</p><p><strong>并不是所有的数据库都支持用来创建集合的 []。</strong></p><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_contact <span class="keyword">LIKE</span> <span class="string">&#x27;[JM]%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_contact;</span><br></pre></td></tr></table></figure><p>此语句的 WHERE 子句中的模式为 ‘[JM]%’，这一搜索模式使用了两个不同的通配符。[KM] 匹配任何一方括号中字母开头的联系人明，它也只能匹配单个字符。因此，任何多余一个字符的名字都不匹配，其后的 % 通配符匹配第一个字符之后的任意数目的字符，返回所需的结果。</p><p>此通配符可以用前缀字符 ^（脱字号）来否定。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_contact <span class="keyword">LIKE</span> <span class="string">&#x27;[^JM]%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_contact;</span><br></pre></td></tr></table></figure><p>此例子与上一个例子查询的是相反的内容。</p><p><strong>Access 中，需要用 ！而不是 ^来否定一个集合，因此，使用的是 [!JM] 而不是 [^JM] 。</strong></p><h4 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h4><p>SQL 的通配符很有用，但是这种功能是有代价的，即通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间。这里给出一些在使用通配符时要记住的技巧。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li><li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处，把通配符置于开始处，搜索起来时最慢的。</li><li>仔细注意通配符的位置，如果放错地方，可能不会返回想要的数据。</li></ul><h4 id="字段的概念"><a href="#字段的概念" class="headerlink" title="字段的概念"></a>字段的概念</h4><p>基本上与列的意思相同，经常互换使用，不过数据库一般称为列，而术语字段通常与计算字段一起使用。</p><p><strong>需要特别注意，只有数据库知道 SELECT 语句中哪些列是实际的表列，哪些列是计算字段。从客户端（如应用程序）来看，计算字段的数据与其他列的数据的返回方式相同</strong></p><h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>拼接：将值联结到一起（将一个值附件到另一个值）构成单个值。</p><p>在 SQL 中的 SELECT 语句中，可以用一个特殊的操作符来拼接两个列。</p><p>根据使用的数据库的不同，操作符也不相同。除了 MySQL 和 MariaDB 必须使用特殊的函数外，可以用加号（+）或两个竖杠（||）来表示。</p><p>具体的用法为： Access 和 SQL Server 使用 + 号，DB2、Oracle、PostgreSQL、SQLite、和 Open Office Base 使用 || 。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> vend_country <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line">Bear Emporium (USA )</span><br><span class="line">Bears R Us (USA )</span><br><span class="line">Doll House Inc. (USA )</span><br><span class="line">Fun <span class="keyword">and</span> Games (England )</span><br><span class="line">Furball Inc. (USA )</span><br><span class="line">Jouets et ours (France )</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name <span class="operator">||</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">||</span> vend_country <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line">Bear Emporium (USA )</span><br><span class="line">Bears R Us (USA )</span><br><span class="line">Doll House Inc. (USA )</span><br><span class="line">Fun <span class="keyword">and</span> Games (England )</span><br><span class="line">Furball Inc. (USA )</span><br><span class="line">Jouets et ours (France )</span><br></pre></td></tr></table></figure><p>上述两个 SELECT 语句拼接一下元素：</p><ul><li>存储在 vend_name 列中的名字</li><li>包含一个空格和一个左圆括号的字符串</li><li>存储在 vend_country 列中的国家</li><li>包含一个右圆括号的字符串</li></ul><p>为了去掉结果中多余的空格，可以使用 SQL 的 RTRIM 函数来完成。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> RTRIM(vend_country) <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line">Bear Emporium (USA)</span><br><span class="line">Bears R Us (USA)</span><br><span class="line">Doll House Inc. (USA)</span><br><span class="line">Fun <span class="keyword">and</span> Games (England)</span><br><span class="line">Furball Inc. (USA)</span><br><span class="line">Jouets et ours (France)</span><br></pre></td></tr></table></figure><p><strong>TRIM 函数，去掉字符串左右两边的空格；RTRIM 函数，去掉字符串右边的空格；LTRIM 函数，去掉字符串左边的空格。</strong></p><h4 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h4><p>SELECT 语句可以很好的拼接地址字段，但是实际上拼接之后的这个列是没有名字的，它只是一个值，如果只是在 SQL 查询工具中查看它并没有什么问题。但是如果要在客户端应用中引用它的话就不可以了，因为一个未命名的列客户端没有办法引用它。</p><p>为了解决这个问题，SQL 支持别名。别名是一个字段的值或值得替换值，别名用 AS 关键字赋予。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> RTRIM(vend_country) <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line">vend_title</span><br><span class="line"></span><br><span class="line">Bear Emporium (USA)</span><br><span class="line">Bears R Us (USA)</span><br><span class="line">Doll House Inc. (USA)</span><br><span class="line">Fun <span class="keyword">and</span> Games (England)</span><br><span class="line">Furball Inc. (USA)</span><br><span class="line">Jouets et ours (France)</span><br></pre></td></tr></table></figure><p>使用||语法的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">||</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">||</span> RTRIM(vend_country) <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure><p>MySQL 和 MariaDB 中使用的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(vend_name, <span class="string">&#x27; (&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure><p>SELECT 语句这里的计算字段，后边跟了文本 AS vend_title，它只是 SQL 创建一个包含指定结算结果的名为 vend_title 的计算字段。从输出可以看到，计算结果与以前的相同，但现在列名为 vend_title ，任何客户端应用都可以按照这个名称引用这个列，就像它是一个世纪的表列一样。</p><p><strong>AS 关键字是可选的，不过最好使用它。</strong></p><p>别名还有其他的用途，常见的用途包括在实际的表列明包含不合法的字符（如空格）时重新命名它， 在原来的名字含混或容易误解时扩充它。</p><p>别名既可以是一个单词也可以是一个字符串。如果是后者，字符串应该在引号中。虽然这种做法是合法的，但不建议这么做，多单词的可读性高，不过会给客户端应用带来各种问题。因此，别名最常见的使用时将多个单词的列名重命名为一个单词的名字。</p><h4 id="执行算数运算"><a href="#执行算数运算" class="headerlink" title="执行算数运算"></a>执行算数运算</h4><p>例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20008</span>;</span><br></pre></td></tr></table></figure><p>从上述例子可以看出来，将数量和单价相乘作为一个新的字段来展示。</p><p>SQL 支持下表中列出的基本算数操作符，圆括号可以用来区分优先顺序。</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;</td><td>除</td></tr></tbody></table><p>SELECT 语句为测试、检验函数和计算提供了很好的方法。虽然 SELECT 通常用于从表中检索数据，但是省略了 FROM 子句后就是简单的访问和处理表达式。，例如 SELECT 3*2; 将返回 6，SELECT Trim(‘abc’); 将返回 abc，SELECT Now(); 使用 Now() 函数来返回当前日期和时间。</p><h4 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>各个数据库的函数差异见下表</p><table><thead><tr><th>函数</th><th>语法</th></tr></thead><tbody><tr><td>提取字符串的组成部分</td><td>Access 使用MID()；DB2、Oracle、PostgreSQL 和 SQLite 使用 SUBSTR()；MySQL 和 SQL Server 使用 SUBSTRING()</td></tr><tr><td>数据类型转换</td><td>Access 和 Oracle 使用多个函数，每种类型的转换有一个函数；DB2 和 PostgreSQL 使用 CAST()；MariaDB、MySQL 和 SQL Server 使用 CONVERT()</td></tr><tr><td>取当前日期</td><td>Access 使用 NOW()；DB2 和 PostgreSQL 使用 CURRENT_DATE；MariaDB 和 MySQL 使用CURDATE()；Oracle 使用 SYSDATE；SQL Server 使用 GETDATE()；SQLite 使用 DATE()</td></tr></tbody></table><h5 id="UPPER-函数"><a href="#UPPER-函数" class="headerlink" title="UPPER() 函数"></a>UPPER() 函数</h5><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, <span class="built_in">UPPER</span>(vend_name) <span class="keyword">AS</span> vend_name_upcase</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"><span class="comment">--------------------------- ----------------------------</span></span><br><span class="line">vend_name vend_name_upcase</span><br><span class="line">Bear Emporium BEAR EMPORIUM</span><br><span class="line">Bears R Us BEARS R US</span><br><span class="line">Doll House Inc. DOLL HOUSE INC.</span><br><span class="line">Fun <span class="keyword">and</span> Games FUN <span class="keyword">AND</span> GAMES</span><br><span class="line">Furball Inc. FURBALL INC.</span><br><span class="line">Jouets et ours JOUETS ET OURS</span><br></pre></td></tr></table></figure><h5 id="一些常用的文本处理函数"><a href="#一些常用的文本处理函数" class="headerlink" title="一些常用的文本处理函数"></a>一些常用的文本处理函数</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>LEFT()（或使用子字符串函数）</td><td>返回字符串左边的字符</td></tr><tr><td>LENGTH()（也使用DATALENGTH()或LEN()）</td><td>返回字符串的长度</td></tr><tr><td>LOWER()（Access使用LCASE()）</td><td>将字符串转换为小写</td></tr><tr><td>LTRIM()</td><td>去掉字符串左边的空格</td></tr><tr><td>RIGHT()（或使用子字符串函数）</td><td>返回字符串右边的字符</td></tr><tr><td>RTRIM()</td><td>去掉字符串右边的空格</td></tr><tr><td>SOUNDEX()</td><td>返回字符串的SOUNDEX值</td></tr><tr><td>UPPER()（Access使用UCASE()）</td><td>将字符串转换为大写</td></tr></tbody></table><p><strong>Microsoft Access 和 PostgreSQL 不支持 SOUNDEX()，因此以下的例子不适用于这些 DBMS。另外，如果在创建SQLite 时使用了 SQLITE_SOUNDEX 编译时选项，那么 SOUNDEX() 在 SQLite 中就可用。因为 SQLITE_SOUNDEX 不是默认的编译时选项，所以多数 SQLite 实现不支持 SOUNDEX() 。</strong></p><h5 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h5><p>各个数据库中日期和时间处理函数是最重要的，但是它们的可移植性是最差的。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> DATEPART(yy, order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br></pre></td></tr></table></figure><p>这个例子（SQL Server 和 Sybase 版本以及 Access 版本）使用了 DATEPART() 函数，顾名思义，此函数返回日期的某一部分。DATEPART() 函数有两个参数，它们分别是返回的成分和从中返回成分的日期。在此例子中，DATEPART() 只从 order_date 列中返回年份。通过与 2012 比较，WHERE 子句只过滤出此年份的订单。</p><p>下面是使用名为 DATE_PART() 的类似函数的 PostgreSQL 版本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> DATE_PART(<span class="string">&#x27;year&#x27;</span>, order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br></pre></td></tr></table></figure><p>Oracle 没有 DATEPART() 函数，不过有几个可用来完成相同检索的日期处理函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> to_number(to_char(order_date, <span class="string">&#x27;YYYY&#x27;</span>)) <span class="operator">=</span> <span class="number">2012</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，to_char() 函数用来提取日期的成分，to_number() 用来将提取出的成分转换为数值，以便能与 2012 进行比较。</p><p>MySQL 和 MariaDB 具有各种日期处理函数，但没有 DATEPART() 。MySQL 和 MariaDB 用户可使用名为 YEAR() 的函数从日期中提取年份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br></pre></td></tr></table></figure><p>在 SQLite 中有个小技巧：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> strftime(<span class="string">&#x27;%Y&#x27;</span>, order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br></pre></td></tr></table></figure><h5 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h5><p>在所有数据库中， 数值函数是最一致，最统一个的函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ABS()</td><td>返回一个数的绝对值</td></tr><tr><td>COS()</td><td>返回一个角度的余弦</td></tr><tr><td>EXP()</td><td>返回一个数的指数值</td></tr><tr><td>PI()</td><td>返回圆周率</td></tr><tr><td>SIN()</td><td>返回一个角度的正弦</td></tr><tr><td>SQRT()</td><td>返回一个数平方根</td></tr><tr><td>TAN()</td><td>返回一个角度的正切</td></tr></tbody></table><h4 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h4><h5 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h5><p>我们经常要汇总数据而不用把他们实际检索出来，为此 SQL 提供了专门的函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的函数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><p>COUNT() 函数右两种使用方式：</p><ul><li>使用 COUNT(*) 对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li><li>使用 COUNT(column) 对特定列中具有值得行进行计数，忽略空值。</li></ul><h5 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h5><ul><li>对所有行执行计算，指定 ALL 参数或不指定参数（因为 ALL 是默认行为）</li><li>只包含不同的值，指定 DISTINCT 参数。</li></ul><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用了 DISTINCT 参数，因此平均值只考虑各个不同的价格</p><h4 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h4><p>这里讲介绍两个新的 SELECT 子句：GROUP BY 子句和 HAVING 子句。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br><span class="line"><span class="comment">------- ---------</span></span><br><span class="line">vend_id num_prods</span><br><span class="line">BRS01 <span class="number">3</span></span><br><span class="line">DLL01 <span class="number">4</span></span><br><span class="line">FNG01 <span class="number">2</span></span><br></pre></td></tr></table></figure><p>上面的 SELECT 语句指定了两个列：vend_id 包含产品供应商的 ID，num_prods 为计算字段（用COUNT(*) 函数建立）。GROUP BY 子句指示 DBMS 按 vend_id 排序并分组数据。这就会对每个 vend_id 而不是整个表计算 num_prods 一次。从输出中可以看到，供应商 BRS01 有 3 个产品，供应商 DLL01 有 4 个产品，而供应商 FNG01 有 2 个产品。因为使用了 GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。GROUP BY 子句指示 DBMS 分组数据，然后对每个组而不是整个结果集进行聚集。</p><p><strong>在使用 GROUP BY 子句时，需要知道一些重要的规定：</strong></p><ul><li>GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</li><li>如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li><li>GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。</li><li>大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。</li><li>除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出。</li><li>如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。</li><li>GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。</li></ul><p>参考链接：</p><p>SQL 必知必会电子版</p><blockquote><p>本文章首发于个人博客 <strong>LLLibra146’s blog</strong><br><strong>本文作者</strong>：LLLibra146<br>更多文章请关注：<img data-src="https://blogimg.d77.xyz/qrcode_for_gh_10d7d04417bb_430.jpg" alt="qrcode"><br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 © <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">BY-NC-ND</a> 许可协议。非商用转载请注明出处！严禁商业转载！<br><strong>本文链接</strong>：<br><a href="https://blog.d77.xyz/archives/1da172c2.html">https://blog.d77.xyz/archives/1da172c2.html</a></p></blockquote></div><footer class="post-footer"><div class="post-tags"><a href="/tags/SQL/" rel="tag"><i class="fa fa-tag"></i> SQL</a> <a href="/tags/%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" rel="tag"><i class="fa fa-tag"></i> 必知必会</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a></div><div class="post-nav"><div class="post-nav-item"><a href="/archives/4744f068.html" rel="prev" title="Linux下7z压缩解压软件区别"><i class="fa fa-chevron-left"></i> Linux下7z压缩解压软件区别</a></div><div class="post-nav-item"><a href="/archives/d23de99f.html" rel="next" title="Python编码命名规范">Python编码命名规范 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments giscus-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">津ICP备15003765号</a></div><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">LLLibra146</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><a href="https://github.com/libra146" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="/js/third-party/fancybox.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.d77.xyz/archives/1da172c2.html"}</script><script src="/js/third-party/quicklink.js"></script><script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"libra146/libra146.github.io","repo_id":"MDEwOlJlcG9zaXRvcnkxOTI0ODgxODA","category":"Announcements","category_id":"DIC_kwDOC3ki9M4CYegl","mapping":"pathname","reactions_enabled":1,"emit_metadata":0,"theme":"light","lang":"zh-CN","input_position":"bottom","loading":"lazy"}</script><script>document.addEventListener("page:loaded",()=>{CONFIG.page.comments&&NexT.utils.loadComments(".giscus-container").then(()=>NexT.utils.getScript("https://giscus.app/client.js",{attributes:{async:!0,crossOrigin:"anonymous","data-repo":CONFIG.giscus.repo,"data-repo-id":CONFIG.giscus.repo_id,"data-category":CONFIG.giscus.category,"data-category-id":CONFIG.giscus.category_id,"data-mapping":CONFIG.giscus.mapping,"data-reactions-enabled":CONFIG.giscus.reactions_enabled,"data-emit-metadata":CONFIG.giscus.emit_metadata,"data-theme":CONFIG.giscus.theme,"data-lang":CONFIG.giscus.lang,"data-input-position":CONFIG.giscus.input_position,"data-loading":CONFIG.giscus.loading},parentNode:document.querySelector(".giscus-container")}))})</script></body></html>